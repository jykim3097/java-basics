# java-basics
기초를 탄탄히! solid foundation

## 210226 

### 메서드 (자바의 일부)

- 반복되는 코드 블록에 이름을 붙여 놓은 것
- 코드를 좀 더 구조화시켜 필요할 때마다 재활용하기 위해서 만듦
- 객체의 기능을 구현하기 위해 만든다
- 메소드 이름은 소문자로 시작하되 카멜표기법으로 작성해라

* return의 의미
	- '값의 반환'과 '메서드의 종료'라는 두 가지 의미가 있다.
 	- void형 메서드에서 return;을 만나면 구문이 종료된다.
		- return 0;과 같이 쓰면 안됨

## 210302 

### 객체와 클래스

- 클래스(설계도) -> 인스턴스(생산) -> 오브젝트(객체)
- main이 있는 클래스 1개와 main이 없는 클래스 여러개로 구성될 수 있다.
- main에서 클래스를 생성해서 쓸 수 있다.
- main이 없는 클래스에는 변수와 메서드들이 들어갈 수 있다.

### 생성자
- 멤버변수를 초기화한다.
- new 키워드 다음에 오는 것을 생성자라고 한다.
- 반환 타입은 없고, 클래스 이름과 대소문자까지 똑같이 만들어야한다.

### 210303 

## 객체지향 프로그래밍 기술 (상속, 은닉, 다형성)

### 가비지 컬렉터
- new로 생성시켰으면 없애는 것도 있어야지
- java가 자동으로 해줌

### 패키지

### 상속 "extends"
- 기존 클래스를 확장해 새로운 클래스를 이끌어내는 것
- 기존 코드를 재사용함으로써 효율 높임

- 기존 클래스의 공통점을 뽑는다.
- 부모 클래스(super class)가 갖고 있는 것은 다 가질 수 있다.
- 단일상속만 가능하다
- object 클래스가 자바의 최상위 클래스, 모든 클래스는 object 클래스를 상속받는다.

### 메서드 재정의 - 오버라이딩, 덮어쓰기
- 상속과 항상 같이 다님
- 상속을 전제로 한다.
- 메서드 반환유형, 이름, 매개 변수 모두 일치해야 한다. = 똑같은 메서드를 더 만든다.
- 부모 클래스로부터 상속받은 메서드를 자식클래스에서 행위를 바꾸거나 보완하기 위해 다시 정의해서 사용하는 것을 의미
- 재정의된 메서드가 '''먼저''' 실행된다.

### 210304 

## 메서드 중복(Overloading)

### 메서드나 생성자의 중복 선언을 허용
- 완전 같으면 안되고, 매개변수의 유형이나 개수를 다르게 선언하는 것을 의미한다.
- 사용 조건
	1. 이름이 같아야 한다.
	2. 반환유형도 같아야 한다.
	3. 매개 변수 유형, 개수, 순서가 달라야 한다.

## this와 super

### this
- 자기 자신 객체를 지정할 때 사용하는 키워드
- 같은 변수명을 가졌을 때 java는 더 가까운 변수를 가져온다.
- this.을 이용하면 같은 클래스 내의 멤버 변수와 메서드를 참조할 수 있다.
### this()
- 나 자신(), 생성자랑 비슷한 모양
- 같은 클래스 안의 다른 생성자를 호출할 수 있다.

### super (클래스)
* this가 나 자신이라면 super는 한단계 위 부모클래스의 객체를 지정할 때 사용하는 클래스
* super.을 사용하면 부모클래스의 멤버를 참조할 수 있다.
* super()는 생성자 내부에서만 사용 가능, 부모클래스의 생성자를 호출하는 방법이다.
* 생성자의 첫 라인에는 반드시 this(), super()가 있는데, 없으면 super()가 묵시적으로 있다..?

## 실제 자바는 상속 계층 구조이다!

* java의 모든 클래스는 object 클래스를 상속받고 있다. object 클래스는 자바의 최상위 클래스이다.
* 클래스 뒤에 아무것도 명시하지 않으면 자동으로 Object의 자식 클래스이다. 암묵적으로 extends object가 있다.
* 오버라이딩 된 메서드에서 원본 메서드가 필요할 때 사용할 수 있다.

### 210305

## 접근 제한자
- 클래스, 멤버변수, 메서드, 생성자의 접근을 제어할 수 있는 제한자
- 가장 앞에 입력
- 예를 들어, 은행 창구는 누구나 이용할 수 있지만, 은행 금고는 외부인이 사용하지 못하게 제한한다. (은행 소속 직원만 사용할 수 있다.)

### 종류 (public, protected, default, private)
- public : 모두 접근 가능 - 은행 창구
	- 초록색
- private : 같은 클래스 내부가 아니면 접근 불가능
	- (은행 소속 직원만 쓸 수 있는) 은행 금고
- default : 접근제한자를 붙이지 않는 형태, 같은 패키지에서만 접근 가능
	- 상속이 안된다.
- protected
	- 같은 클래스, 패키지에서는 접근 가능
	- 상속이 안된 다른 패키지에 속해있는 클래스는 접근 불가 = 상속이 된 경우에는 가능 
	- super()를 통한 접근이 가능
	- 노란색

- 접근제한자를 잘 사용하면 메서드 접근에 대한 차별을 두어 더 잘 활용할 수 있다.

## 상속, '은닉', 다형성

### 캡슐화

- 중요한 내부 구현은 숨기고 필요한 부분만 보이게 한다.
- 접근 제한자를 활용한다.
- 데이터는 멤버변수에 저장되고, private 접근 제한자를 통해 은닉한다.
- 이 은닉된 데이터(멤버변수)에 접근하기 위해 public 메서드를 통해 접근한다.
- 변수의 값을 변경시키는 데 사용하는 메서드 = setter 메서드
	- 저장 느낌
- 변수의 값을 얻어오는 데 사용하는 메서드 = getter 메서드
- 물론 메서드나 생성자도 접근제한자를 사용해 은닉할 수 있다.

- 변수를 public으로 선언하면 모든 값을 저장할 수 있다. 그런데 원하지 않는 값이나 잘못된 값도 저장이 될 수 있다.
- 그렇기 때문에 변수를 private으로 선언하고, public으로 선언된 메서드를 통해 변수에 접근한다.

## 클래스 배열

### String
- 문자열 타입이지만 클래스 타입이기도 하다
- 그런데 String[]처럼 배열이 만들어진다는 것은 클래스도 배열을 만들 수 있다는 것을 의미한다.


### 210308

## 다형성(Polymorphimsm)
- 객체가 여러 형태를 가진다, 여러 유형으로 사용될 수 있다.
- 상속을 전제 조건으로 한다.
- 다형성이란 자식 클래스가 부모클래스의 타입을 가질 수 있다라는 말

- 원래는 Student s = new Student(); 로 쓰였는데
- 부모 클래스 Person p = new Student(); 도 쓰일 수 있다.

- 이때 기능은 타입을 따라가므로 Person의 기능만 사용할 수 있다.

- int x = 1;
- double y = x;
- 일 때, y는 1.0이 출력되는 것과 같은 원리


- 그런데 오버라이딩된 메서드는 (Student의 메서드가) 먼저 실행된다.

## 클래스 Casting

### 강제 타입 변환 (Type Casting)
- 부모 타입을 자식 타입으로 변환하는 것
- 부모 타입으로 한 번 형변환이 된 자식 객체만 강제 타입 변환을 사용할 수 있다.
- 자식으로 만들었던 클래스만 다시 자식으로 돌아갈 수 있다.

## 클래스 타입 확인, intanceof 키워드

- 객체가 지정한 클래스의 인스턴스인지 아닌지 검사할 때 사용하는 연산자


### 210309

## 정적 제한자 static
* **변수나 메서드**에 적용되는 자바의 키워드, 생성자에는 x
* static에 this를 생성할 수 없다.
	* static은 클래스 밖에 만들어지는 것이고, this는 나 자신을 가르키는 것이기 때문이다.
* 초록색 원에 s가 붙어있으면 static 메서드라는 뜻이다!!!
* static 메서드는 non-static 메서드로 오버라이딩할 수 없다.
* static끼리도 오버라이딩 안된다.
* 대표적인 static 메서드는 main 메서드

### static 변수
* 모든 객체들이 공유하는 공유 변수가 됨
* **객체 생성 없이 클래스 이름만으로 참조 가능**
	* (클래스 이름).(static 변수)
* 어디서든 똑같은 값, ex) 계산기의 pi
* 남발하기보다는 필요한 곳에 잘 써줘야 함

### static 메서드
* static 변수처럼 클래스의 객체 생성 없이도 참조가 가능하다
* static 메서드 안에서는 일반 멤버 변수(non-static)를 사용할 수 없다.
	* static 메서드에서는 static 변수만 사용할 수 있다.

### 컴파일 과정
* 클래스를 한 번 쫙 보고 classLoader라는 걸 통해서 올려!
* 이 때 한 번 훑어보면서 static 변수들이 생성이 된다.
* 그래서 static 변수는 먼저 만들어지기 때문에 static 메서드에서 사용이 가능하고, 일반 변수는 static 메서드에서 사용이 불가능하다.
* 그런데 정말 static 메서드 안에서 일반 변수를 사용할 수 없을까?
	* 있다!
	* 마치 main 메서드(static)에서 객체를 생성했던 것처럼 메서드에서 객체를 생성해서 사용한다면 일반 멤버변수도 사용할 수 있다.

> main 메서드도 사실 아무 클래스에나 들어가도 된다. 그러나 실행 메서드와 일반 메서드가 한 클래스에 있는 것은 객체지향적이라고 볼 수 없다.

### static initializer (정적 초기화자)
* static 변수는 생성자를 안거친다, 객체 생성을 안하니까
* static 변수는 정적초기화자를 통해 초기화 한다.
* 클래스가 로딩될 때 생성자와 main 메서드 앞에 단 한 번만 실행된다.
~~~
static {
	System.out.println("static initializer가 수행됨");
}
~~~

### static에 대해 알아둬야할 것
1. static 멤버는 객체 생성 없이 클래스명.이름으로 참초
2. static 변수는 객체간 값의 공유 의미, 변수들이 같은 값을 갖는다.
3. static 메서드는 같은 static 멤버만 참조 가능하다.

## 싱글톤 디자인 패턴
* 클래스 객체를 하나만 생성해 모든 곳에서 하나의 객체에만 접근하게 해 전역의 개념으로 객체를 사용할 수 있다.
* 객체의 생성을 제한하기 위해 사용한다.

## final - 변경 금지의 규제 키워드
* 주로 메서드와 변수에 적용된다.
* final과 static 모두 클래스에도 적용할 수 있지만 많이 안쓰나범..
* 상속이 안된다. 서브클래스를 가질 수 없다.
* 상속이 안된다 = 재정의도 안된다 

### final 클래스, final 메서드
* final 키워드가 클래스에 붙으면 상속 금지
* 메서드에 붙으면 오버라이딩 금지

### final 변수
* final 변수는 값을 변경할 수 없다.
* final 변수 초기화 하는 방법
	1. 직접 초기화
	2. 생성자를 통해 초기화
		* 객체마다 다른 값으로 저장할 수 있다.
		* 다만, 한 번 저장되면 변경할 수 없다.
* 동그라미 옆에 f가 붙어있으면 final 변수

## static과 final이 동시에 붙으면 상수!
* 상수 이름은 모두 대문자로 작성하는 것이 관례
* 한 클래스에 상수를 다 저장해놓고 클래스명. 해서 사용하는 경우도 있다,

## abstract

### 의미
* 클래스와 메서드에 적용된다.
* 실체 클래스들의 메서드의 이름을 통일할 목적으로 사용한다.
* 추상 메서드가 있는 클래스는 반드시 추상 클래스여야한다.
* 그러나 반대로 추상 클래스에는 일반 메서드도 선언할 수 있다.
* 부모가 가지고 있는 기능, 또는 필요한 기능을 자식 클래스에서 반드시 가져야하는 경우, 부모 클래스를 추상클래스로 만들어야한다.

### 추상클래스 - 추상메서드
* 둘은 반드시 같이 다닌다.
* 추상 클래스 : 추상 메서드를 선언할 수 있는 클래스, 단 객체 생성은 할 수 없다.
* 자식이 super()를 호출해서 추상 클래스의 객체를 생성하기 때문에 생성자가 꼭 있어야한다.
* 추상 메서드 : 몸체가 없는(중괄호{} 가 없는) 메세드 
* 추상 클래스를 쓸 때 오버라이딩을 꼭 써서 써야된다.
* 동글뱅이에 A가 붙어있으면 추상클래스!

### 210310

## static, final, abstract

### static
* 접근제한자 다음
* 변수랑 메서드에 기본적으로 쓰인다.
	* static 변수 : 공유 변수
		* 변수가 객체마다 만들어지는 게 아니고 한 개만 만들어져서 공유한다
		* 클래스들 사이에서 같은 값을 갖는다
	* static 메서드
		* 변수처럼 값을 공유하는 게 아니어서 **static의 사용 범위**가 중요하다.
		* 같은 static만 참조할 수 있다.
* static은 클래스 내에서 생성하지만 내부적으로 클래스 밖에 만들어진다.
	* 즉, 클래스 멤버가 아니기 때문에 객체를 생성할 수 없다.
	* (클래스명).(static) 으로 접근한다.

### 싱글톤 패턴
* 구조에 관련된 내용, 방법론
* 외우기보다는 코드를 보고 해석할 수 있으면 된다.
* 클래스가 100번 호출되더라도 객체를 **한 번만** 생성되게 한다.
* 방법
	1. private static으로 선언
		* private : 외부에서 접근 불가
		* static : 1개다!
	2. 생성자를 private으로 선언해 외부에서 접근 불가능하게 함

### final
* 반환 유형 앞에 붙는다.
* 상수는 아님, 직접 선언할 때는 고정이 되지만 생성자를 통해 값을 지정할 경우에는 다르게 저장되니까.
	* public static final 이라고 설정하면 상수!
		* 어디서나 사용 가능한, 1개의, 변경 불가능한 값 = 상수
		* static 안에서 초기화할 수도 있다.
* final class : 상속 금지
	* 대표적인 예) String, math, Arrays
* final method : 오버라이딩 금지
* final 변수 : 변경 금지

### abstract
*  final과 반대로 이해, final이 금지라면 abstract는 강제
* 부모클래스는 공통기능을 갖고, 자식클래스는 부모클래스를 상속해 실질적으로 사용하는 클래스다.
* 그래서 부모클래스를 추상화한다.
* 추상 부모클래스의 기능을 자식클래스에서 사용하게 하려면 추상 메서드를 만들어 사용해야한다.
* 추상메서드 : 몸체가 없는 불완전한 메서드
* 자바에서 abastract의 의미
	* 무조건 abstract로 설계할 필요는 없다.
	* 자바 내부에 많은 클래스들이 abstract 클래스로 정의되어있다는 것은 알아 두어야 한다.
	* 또, 자식 클래스로 생성해서 부모(추상)클래스에 저장해서 사용 가능하다는 것에 익숙해져야 한다.

## 인터페이스
* 내용이 방대하다
* ui할 때 그 인터페이스가 아니다
	* ui는 사용자와 프로그램의 매개체
* 여기서 인터페이스는 main과 class의 매개체 

### 상수, 추상메서드만 가지고 있는 인터페이스
* 인터페이스는 클래스가 아니니까 일반 변수와 일반 메서드를 사용할 수 없다.
* 인터페이스에서 선언된 변수는 public static final을 생략하더라도 컴파일 과정에서 자동으로 붙게 된다. (상수)
* 인터페이스에서 abstract라도 붙이지 않고 선언해도 자동으로 붙는다. (추상 메서드)
* 추상 클래스와 인터페이스는 90% 정도 비슷하다

### 인터페이스는 왜 생겼을까?
* 클래스는 다중 상속을 지원하지 않는다.
* 부모 클래스를 추상클래스로 정의하고
* 자식 클래스 중에 한 자식 클래스에만 특정 클래스를 줄 때 용이
* 특정 클래스를 인터페이스로 정의하고 추상 메서드로 기능을 정의한다 
* 그리고 이를 상속하는 형태로 사용한다.
* 클래스 이름 뒤에 **implements** 키워드를 사용한다.

### 인터페이스의 기능(문법) 1 - 다중 상속을 지원한다.
* 클래스가 아니니까 여러 인터페이스를 동시에 상속할 수 있다.
	* 단, 인터페이스의 **모든 추상메서드를 오버라이딩**해줘야 한다.

### 인터페이스의 기능2 - 메서드 명세서
* 인터페이스에는 추상메서드를 정의하므로 = 객체의 사용 방법을 정의한 타입으로 = 메서드 명세서
* 객체의 교환성을 높여줘 다형성을 구현하는 매우 중요한 역할이다.

### 인터페이스의 기능3
* 사용방법이 동일한 클래스를 만드는 기술
* 인터페이스를 사용하면 형식에 맞춰 원하는대로 재정의할 수 있다.

### 210311

## interface

* 클래스로는 다중 상속이 안되는데 한 자식 클래스에게만 특정 기능을 주고 싶을 때 사용한다.
	* 그렇다고 이럴 때만 쓴다 이건 아님
* 한 클래스가 3개 이상의 객체가 될 수 있다. → 다형성을 구현하는 데 매우 중요한 역할
* 사용 **방법**이 동일한 클래스를 만드는 기술
	* 예를 들어, A 회사에서 정의한 소프트웨어를 B, C 회사가 사용하려고 한다면 B, C 회사는 형식에 맞춰 각자의 사용 방법을 정의할 것이다

### 다중 상속 가능
* interface 간에도 상속이 가능하다, extends를 이용
* 한 자식 클래스 위에 모든 부모 클래스의 추상 메서드는 모두 오버라이딩해야한다.

### 인터페이스 정리
* 상수와 추상메서드만을 구성멤버로 갖는다
* 다중 상속을 지원한다.
* 인터페이스는 메서드 명세서로, 다형성을 구현하는 매우 중요한 역할을 한다.
	* 인터페이스도 데이터 타입(부모)이 될 수 있다.
* 사용 방법이 동일한 클래스를 만드는 기술이다.

### 인터페이스와 추상클래스의 차이?
* 추상클래스를 쓰는 이유? 오버라이딩을 강제화하고 싶을 때 
* 인터페이스를 쓰는 이유? 클래스와 클래스의 매개체로 오버라이딩을 강제화하면서 다중 상속까지 받을 수 있다.
* 거의 비슷하지만 **똑같지 않다!!**

## 예외처리

### 예외란? = Error
* 예외는 크게 두개
	1. 문법적으로 틀린 거 (by컴파일러)
		1. 컴파일러 체크 예외
		2. 실행 예외 (Runtime exception)
			* 문법적으로 틀린 건 아니지만 실행시키면 뜨는 에러
	2. 프로그램 외부적인 문제 (내가 해결할 수 있는 게 아님)

### 예외 처리 방법 1 - try~catch~finally
```java
try {
	코드 작성
} catch(Exception e) {
	처리 영역
} finally {
	무조건 실행
}
```

### 다중 catch 
* 정확한 exception 이름을 catch문에 넣어야 하고, 상위 예외 클래스(Exception)를 가장 아래에 두어야 한다.

### 예외 처리 클래스도 상속 관계를 갖는다
* Throwable 
	* Error - 손 델 수 없는 에러
	* Exceprion - 런타임에러
		* 이 안에 모든 에러가 있기 때문에 Exception 하나로 모든 예외를 처리할 수 있다.

#### 클래스명 위에 마우스 대고 ctrl + t 하면 계층구조가 싹 나옴

### 210312

## 예외처리
### 예외 처리 방법2 - 예외 떠넘기기
* 메서드에서의 예외처리 - **throws**
	* 메서드를 호출한 곳으로 예외를 넘긴다.
	* 호출문에서 예외처리를 대신한다.
	* 메서드 뒤에 throws Exception을 붙여서 사용
	* 예외가 날 수도 있다 라고 경고를 주는 것
	* 예외가 나는 부분에서 바로 예외를 넘기기 때문에 메서드의 강제종료를 발생시킬 수 있다.

### 예외 강제 발생시키기
* 예외 만들기 - throw new Exception
	* 만들어서 throws Exception이나 try-catch문으로 보내준다.
	* throw를 사용하려면 throws를 꼭 써줘야한다.
* 왜 예외를 생성하는가?
	* 반환이 있는 일반 메서드에서 강제로 종료시킬 수 있다.

### 사용자 정의 예외
* 예외 클래스 직접 만들기
	* Exception 클래스를 상속해 사용
* 이름 끝에 Exception이라고 적어주기

## API - java.lang 패키지
* 라이브러리 : 미리 만들어져있는 기능
* API : 라이브러리를 잘 활용하게끔 정의한 모음
* Systme, String, Math, Object ... ⊂ java.lang 패키지
* java.lang 패키지는 자바의 기본 클래스들을 담고 있는 패키지
	* import 구문 없이 사용할 수 있다.

### System 클래스
* 입력과 출력은 Stream 클래스가 관장한다.
* System.in : InputStream에 접근해서 기능을 쓴다.
* System.out : PrintStream 객체에 접근해서 기능을 쓴다.

### 210315

## API - java.lang 패키지
* 기능의 사용 방법을 중간에 연결해주는 매개체
* API 쓰세요 = 문서를 보고 적절하게 쓰세요

## String 클래스 - 문자열
* 두 줄은 같은 뜻이다.
```java
String str = "abc";
char data[] = {'a', 'b', 'c'};
```

* String 클래스의 static 메서드 사용 : String.(메서드이름) 
* 주요메서드
	* charAt() 
	* indexOf()
	* **length()**
	* **replace()**
	* **substring()**
	* toUpperCase()
	* trim() : 문자열 앞 뒤의 공백 제거
	* equals()
	* **valueOf()** : 숫자를 문자로 변경, static 메서드
	* **split()**
		* regex : 특정 패턴을 가진 문자열
		* 매개변수를 통해 배열의 길이를 정할 수 있다
	* contains()

### 210316

## 라이브러리 만들기
1. Export > Java > jar file(java의 압축파일)
	* java 파일에 메인메소드가 없어야함
2. 사용하고자하는 프로젝트에 lib 폴더를 만들고 build path > jar 파일을 추가한다
3. 그러면 referenced libraries라는 게 생기고 그 프로젝트 내에서 함수처럼 사용할 수 있다.

## String의 단점을 보완한 StringBuilder
* 메모리를 과소비하는 String의 단점을 보완하는 클래스
* 객체를 한 번 만들고 그걸 계속 변경해서 쓰는 방법
	* 1000번 바꿔도 1개를 유지
	* String은 1000번 바꾸면 1000개가 생김
* builder와 buffer는 똑같은데, buffer가 조금 더 안정적
	* 안정적? 쓰레드(프로그램 실행 흐름)가 여러개일 때 
* String과 StringBuffer는 다른 타입!
	* StringBuffer 클래스타입을 문자열 타입으로 변경하고 싶으면 String으로 변경해서 사용!

* 코테나 알고리즘 공부할 때 메서드 쓰는 게 더 깔끔하다, 쓰지 말라는 건 조건이 붙어있으면 쓰지 말 것

## Wrapper 클래스
* 기본 타입의 값을 갖는 객체
* 기본 타입의 값을 객체 내부에 두고 포장하기 때문
* 기본 타입의 값은 외부에서 변경할 수 없다.
* 변경하고 싶으면 새로운 wrapper 객체를 생성하야 한다
* Byte, Short, Integer, Double, Float 등등
* 박싱(Boxing) : 기본 타입의 값을 포장 객체로 만드는 과정
* 언박싱(Unboxing) : wrapper 객체에서 기본 타입의 값을 얻어내는 과정
* java 1.8 버전부터 AutoBoxing을 지원함
	```java
	byte b = 1;
	Byte bb = 1;
	String s = " ";
	```
* **문자열을 숫자로 변환할 때 제일 많이 사용한다!**

## java.util
* 사용하기에 유용한 기능들을 모아놓은 것

### 주요 메서드
* binarySearch(배열, 찾는 값) : 이진탐색 : 찾는 값의 인덱스를 리턴
* copy(원본 배열, 복사할길이)
* copyOfRange(원본 배열, 시작인덱스, 끝인덱스)
* sort(배열)
* toSortin(배열)

### 210317

## Date 클래스 - 날짜, SimpleDateFormat클래스 (날짜 포맷)

* s에는 날짜 형식이 들어간다
* Date date = new Date(); 를 하면 우리나라시 기준으로 date에 날짜가 들어간다

## Random 클래스

## StringTokenizer
* new Tokenizer(문자열, 구분자)
	* 구분자에 여러 값을 한 번에 입력할 수 있다.
* new Tokenizer(문자열, 구분자, 구분자포함여부)
	* 구분자 포함 여부는 boolean 타입으로 true를 입력하면 구분자도 토큰에 포함된다.
	* 구분자 기준으로 자르고, 구분자도 포함해서 출력한다.

## 제네릭

* 클래스나 인터페이스 선언에 유형 매개변수가 들어있는 클래스
* <> 부호가 붙고, 그 사이에 파라미터가 있다.

### 제내릭이 없는 코드가 갖는 문제
* 제네릭이 없는 코드
```java
public class ABC {

	private Object obj;
	
	public void setObj(Object obj){
		this.obj = obj;
	}

	public Object getObj(){
		return obj;
	}
}
```
	* ABC 클래스는 무엇이든 다 담을 수 있다
	* 담을 때는 무엇이든 담을 수 있지만, 사용할 때는 형변환을 해줘야하기 때문에 형변환을 잘못하면 오류가 발생할 수 있다.
* 제네릭이 있는 코드
```java
public class ABC<T> {

	private T t;
	
	public void set(T t){
		this.t = t;
	}

	public T get(){
		return t;
	}
}
```
	* T에 타입을 미리 지정해줄 수 있다.

## Collection Framework
### Collection
* 배열과 유사한데 배열보다 저장/조회/수정/삭제(자료구조)하는 작업을 더 쉽게 처리할 수 있다.
* 데이터 적재 클래스 자료구조
* 배열의 한계점 : 크기가 고정값이다
* Collection의 배열 3가지 : Set, List, Queue : 크기가 동적이다. (모두 인터페이스)
	* 추가하면 자동으로 배열 크기가 늘어나고, 삭제하면 자동으로 줄어든다.
	* 배열 크기를 고려하지 않아도 된다.
	* **List** : 순서(인덱스가 있다.), 값이 중복될 수 있다 = 배열 + 크기 조절 능력
		* List를 ArrayList와 Vector가 상속받는데
		* 그래서 List list = new ArrayList(); 로 사용할 수 있다.
			* 다형성!
		* ArrayList를 사용하는 게 안정적이다.
	* Set ↔ List : 순서 없고, 중복도 안된다
		* 로또 바구니라고 생각하면 된다.
	* Queue : 컴퓨터 프로세스와 똑같다. 먼저 들어간 건 먼저 나온다(FIFO) ↔ Stack(FILO) : 스택은 List
	* LinkedList는 List와 Queue를 다 상속받는다
		```java
		LinkedList list = new List();
		LinkedList list = new Queue();
		``` 
* **Map** : Collection과는 동떨어져있다.
	* 키, 값이 통째로 저장된다
* Collection의 상속표는 다 외워라

### 특징
* 객체를 저장할 수 있는 자료구조 제공
* 컬렉션에 저장된 객체나 변수를 엘리먼트라고 한다
	* 객체 = 엘리먼트 or 변수 = 엘리먼트
* 지금까지 배운 배열을 다 List로 대체할 수 있다.

### List 컬렉션
* 주요 메서드
	* 추가할 때 add, 얻을 때 get, 크기 확인 size(), 저장된 값 확인 toString()
* 배열처럼 인덱스에 접근해서 쓰는 것이 아니고 메서드를 이용해서 사용한다.

### 210318

## 제네릭, 컬렉션 복습
* 클래스에 전달되는 매개변수
* <>에는 타입이 들어간다!
* 기본형 타입은 저장될 수 없다.

### 컬렉션
* 최상위 인터페이스 : 컬렉션
* 컬렉션 인터페이스를 상속받는 세가지 인터페이스 : Set, List, Queue + Map
	* List와 Queue / Set, List, Map
	* 모두 동적인 크기를 갖는다 → 배열보다 편리하게 사용할 수 있다.
	* Set : 순서 X, 중복 X
	* List : 순서 O, 중복 O - 앞으로 계속 쓰게될 것
		* 순서가 있다 = 인덱스 번호를 사용할 수 있다
		* 중복이 된다 = 같은 값도 들어간다
		* 대표적으로 ArrayList, Vector, Stack 을 사용
			* ArrayList, Vector는 같은 건데 멀티쓰레드 환경에서 ArrayList가 더 안정적 
	* Queue
	* LinkedList : List와 Queue 모두 상속받는 클래스
		* Queue를 상속받을 땐 Queue 메서드를 사용할 수 있다.
	* Map : 사전 같이 사용됨

### LinkedList 예제
* 인접 참조를 링크해 체인처럼 관리
* 특정 인덱스의 객체를 제거하면 앞,뒤 링크만 변경되고, 나머지 링크는 변경되지 않아 빈번한 객체의 삭제가 ArrayList보다 좋은 성능을 갖는다


### 210319

## Collection Framework 복습
* LinkedList는 List, Queue(FIFO), Stack(LIFO)의 기능을 다 갖고 있다.
	* Stack like 멘토스 : 쌓을 때는 밑에서부터 쌓지만, 먹을 때는 위에서부터 먹는다
* ArrayList는 배열 기반
* LinkedList는 배열 기반이 아니고 **링크로 인접 값을 참조**한다
	* 어떻게 보면 객체 기반

## LinkedList의 주요 메서드

### stack처럼 동착하는 LinkedList
* 특징 : stack 처럼 동작한다 → LIFO
* push : 처음 push한 게 인덱스 번호가 제일 크다
* pop : 가장 최근에 push한 값(index 0번)이 삭제된다.
* peek : 제일 첫번째 값만 읽는다
* Vector를 상속받는다.

### queue처럼 동작하는 LinkedList
* 특징 : queue처럼 동작한다 → FIFO
* offer : 순서대로 저장된다
* poll : 처음 저장한 값이 처음 삭제된다
* peek : 값만 읽는다

## Set (순서 X, 중복 X) ↔ List
* 순서가 없다 = 인덱스 번호를 사용하지 못한다
* 로또 바구니

### Set의 주요 메서드
* Iterator(인터페이스) : 반복자
	* Set 계열은 번호가 없기 때문에 값에 접근할 때 사용한다.
	* StringTokenizer와 유사하게 사용한다
		* hasNext(), next()로 다음값에 접근
	* iterator()는 Iterator 타입으로 반환한다.
* TreeSet : Tree 구조 기반으로 생성된 클래스, Set 기능 + 자동정렬 기능
	* TreeSet이 SortedSet을 implements 하기 때문에 가능

### 컬렉션에서 탈출 조건은 size()를 활용해봐랏

## Map 계열(key-value) 
* ☆중요!☆ 잘 쓸 줄 알아야한다
* python의 dictionary, js의 객체
* 키 : 값, 하나로 묶여있는 형태를 **엔트리**라고 한다.
* 맵 구조안에 엔트리가 통째로 들어가 있다.
* 키는 고유한 값이다, id를 가진 유저정보 등을 저장하기가 좋다
* 탐색이 엄청 빠르다

### 주요 메서드
* put : 저장하다
* get : 가져온다
* keySet() : key만 뽑아서 반복자로 바꿔주는 기능
* entrySet() : entry만 뽑아서 반복자로 바꿔주는 기능

### 210322

## 지난 주 복습

### API - java.util : 사용하기에 편리한 기능
* 컬렉션 프레임워크
* 제네릭 문법을 이해할 줄 알아야한다
* Set, List, Map 의 특징 잘 알아두기
	* 사용방법 중요!!!

## API - IO 패키지
* InputStream과 OutputStream
	* Input : 입력

### Stream이란?
* 데이터의 흐름(흐르는 **통로**)
* 눈에 보이지 않게 자동 생성
* 종류
	* byte 기반 스트림
		* 데이터를 가장 작은 단위인 byte단위로 전달
		* 문자, 그림 등 여러 데이터를 보낼 수 있음
		* Byte Stream 아래 최상위 부모 클래스는 InputStream, OutputStream
		* InputStream, OutputStream은 추상클래스
	* 문자 기반 스트림 (Character Stream)
		* 데이터를 문자 크기(2byte)씩 전달
		* 오직 문자만 보낼 수 있도록 특화되어 있음(문자만 보낼 수 있음)
		* Reader, Writer 
	
	* Error Stream(중요도 낮음)
* Stream 중간에서 데이터를 모았다가 보내주기도 하는데 그 모으는 곳이 바로 buffer다

### '\' 한 개만 쓰면 탈출문자로 인식하기 때문에 '\\' 2개를 써야 문자 그대로 인식한다
### 캐리지 리턴
* 줄바꿈과 함께 다시 종이 제일 왼쪽으로 옮겨가게 하는 기능

## API-IO(입출력 성능 향상 보조 스트림)
### BufferedWriter
* 텍스트 파일을 프로그램으로 읽을 때 사용하는 문자 기반 스트림
* 데이터를 읽고 버퍼에 저장해 한 번에 쓴다 → 속도가 빠르다
* flush() : 모은 buffer를 밀어내는 메서드
* 버퍼가 가득찼을 때만 출력하므로 flush()를 사용해 밀어내줘야한다.
* BufferedInputStream, BufferedOutputStream

### BufferedReader
* 읽어들이는 것을 빠르게
* 문자 기반 stream 성능 향상 보조 스트림

### 210323

## 익명객체와 람다식

## 익명 객체란?
* 클래스 안에 클래스, 내부클래스라고도 한다, 이름이 없는 클래스
* 가독성이 떨어지므로 가장 적절한 곳에만 쓴다
* 구현 클래스가 매번 달라지거나, 한 번만 사용하는 경우 선언

## 람다식이란?
* 함수를 매개 값으로 전달하고 결과를 받는 코드로 구성된다
* 식 : (매개변수, 매개변수) -> { 실행문 }
* 함수적 프로그래밍을 최근에 선호한다.
	* 점 찍고 점 찍고 점 찍고

* 함수적 프로그래밍이 객체 지향 프로그래밍보다 효율적
	1) 대용량 데이터 처리 시
	2) 이벤트 지향 프로그램 시

* 함수적 인터페이스의 익명 구현 객체를 대신 함 = 함수적 인터페이스 사용 시에만 사용
* 함수적 인터페이스란? **추상 메서드가 1개인 인터페이스**

* 장점
	* 코드가 간결해진다 > 그런데 모르는 사람은 해석을 못함
	* 컬렉션 요소 처리가 쉬워진다

### 활용 - 람다식을 적용하기 위한 스트림 소개
* 앞에서 배운 스트림(파일 입출력 스트림)이 아님
* 반복자 스트림이란?
	* **컬렉션**의 저장 요소를 하나씩 참조하도록 도와주는 **반복자**
	* 람다식으로 처리할 수 있게 해주는 반복자
	* Iterator와 비슷하다
	* 대부분 메서드는 함수적 인터페이스 타입이다

### 210324

## 스트림
* 자바 8부터 추가된 컬렉션의 저장 요소를 하나씩 참조해 람다식으로 처리할 수 있도록 해주는 **반복자**
* Iterator와 비슷한 역할을 하지만 람다식으로 코드를 처리할 수 있어 코드가 좀 더 간결하다.
* 내부 반복자를 사용해서 병렬처리가 쉽다
* 외부 반복자와 내부 반복자
	* 외부반복자 : 반복문으로 요소에 접근해 조작하는 방식
	* 내부반복자 : 처리할 함수를 컬렉션에게 넘겨서 반복 처리
		* 컬렉션 내부에서 요소들을 반복시킴
		* 개발자는 코드만 작성한다
* 병렬 처리 : 한가지 작업을 서브 작업을 나누고, 서브 작업들을 분리된 스레드에서 병렬적으로 처리하는 것

### 스트림 메서드
* list.stream() - 스트림 객체를 얻는다
* 파이프라인 : 여러개의 stream이 연결되어 있는 구조
* [컬렉션, 배열] = [오리지널 스트림][중간스트림-중간처리][집계처리결과물-최종처리]=결과


### 중간처리 메서드
* 처리한 결과를 Stream형태로 반환
* 주요 메서드 
	* distinct() : 중복 제거
	* sorted() : 정렬
	* filter() : 거르는 메서드
	* mapXXX()
		* 요소를 대체하는 요소로 구성된 새로운 스트림 리턴
		* map - **새로운 Stream** 형태로 반환
		* mapToDouble - DoubleStream 형태로 반환 ...

### 최종처리 메서드
* 최종적으로 받을 값
* 처리한 결과를 정수나 실수 등으로 반환
* 더 이상 스트림을 사용하지 못하게 반환하는 메서드

* 주요 메서드
	* forEach() - 결과 출력 시 사용, **원본 변하지 않음**
	* collect() - 새로운 리스트를 만든다, 컬렉션 객체를 List, Set, Map으로 변환처리할 때 사용

### 람다를 적용하는 함수적 인터페이스의 종류
* Consumer
	* 매개변수는 있고 반환은 없는 함수적 인터페이스
	* 받은 값을 소비만 한다고 해서 "소비자"
* Predicate
	* 매개변수를 받고, 반환은 boolean

## 정규표현식
* 문자열이 정해진 패턴으로 구성되어 있는지 검증해야할 때 사용
* ex) 이메일, 전화번호
### Pattern 클래스
* matcher(), matchers() 메서드가 있다
* static 메서드
	* compile(패턴) : 정규표현엔진을 만들어낸다
	* matcher(검증 데이터) : 데이터를 비교해 Matcher 클래스로 반환
	* matchers(패턴, 검증데이터) : 패턴으로 비교해 boolean형으로 반환
* 자주 사용되는 패턴
	* \\d{3} : 연속된 숫자 3개
	* \\d{3,5} : 숫자 3 이상 5 이하
	* \\d : 숫자
	* \\d+ : 숫자 여러개
	* \\w : 문자
	* \\w+ : 문자 여러개
	* [0-9] : 0-9 사이 숫자
	* [a-z] : a-z 사이 문자
	* [가-힣] : 한글
	* \\. \\[ \\? . [ ? 등 특정 문자
* 정규표현식 메타문자에 포함되지 않는 글자나 특수문자는 그대로 입력한다.

### 210326

## 멀티 Thread

* 멀티 태스킹 : 두가지 작업을 동시에 처리하는 것
* 메신저같은 app은 한 프로그램 안에서 멀티태스킹을 동시에 하기도 함
* Thread : 프로그램의 실행흐름
	* 프로그램 내에 thread가 2개라면 **두 개의 코드 흐름이 생긴다**는 뜻
* lang 패키지에 들어있다

### Thread 사용 방법 2가지
* 비슷한데 조금 다르다
1) Runnable 인터페이스를 상속받아 사용하는 방법
	* 쓸 수 있는 게 한정적이다
	* run() 추상메서드만 오버라이딩(재정의)
2) Thread 클래스를 상속받아 사용하는 방법

* 두 개의 차이는?
	* Runnable은 인터페이스니까 thread 실행의 기능만 정의되어 있어 클래스 내부에서 사용할 수 있는 메서드가 한정적 ( thread의 static 메서드는 전부 사용 가능)
	* thread 클래스를 상속받으면 갖고 있는 기능을 전부 받아서 사용할 수 있다.

### Thread 기본 메서드
* start() : Thread 클래스 실행
* **(static)**currentThread() : 현재 Thread 반환
* getName() : Thread 이름 반환
* **(static)**sleep() : Thread 잠시 멈춤
* yield() : Thread 실행을 다른 Thread에게 양보
* join() : 해당 Thread를 우선 실행

### Thread 실행
* 1개의 객체를 두개의 Thread한테 전달해 실행하는 방법
* Thread마다 있는 하나의 객체를 실행하는 방법

### 멀티Thread는 순서 보장을 하지 않는다

### 동기화 메서드 synchronized
* Thread가 사용중인 객체를 다른 Thread가 변경할 수 없도록 객체에 lock을 걸어 다른 Thread가 사용하지 못하도록 한다.
* 비동기 : 여러가지 일을 동시에 처리한다.
* 동기 : 여러가지 일을 순서대로 처리한다.

## 자바 과정에서 안배운것
### swing
* 윈도우 응용프로그램에 ui를 만드는 것
### java.net 패키지

### 210420

## JDBC : Java DataBasce Connected 
### 새로운 시작! 언어와 DB의 연결
* 필요한 데이터를 DB에서 JAVA로 가져오고
* 저장할 데이터를 JAVA에서 DB로 가져오고
* 고전 방법, 근본이 된다
* 속도상으로 빨라서 여전히 사용하고 있다

### JDBC 프로그래밍
* JAVA API, 언어와 DB를 연결해주는 연결자
* 인터페이스로 작성되어있다
* ojdbc.jar : JDBC 드라이버
	* 이클립스에 jar 파일 연결하는 방법
	* 프로젝트에 lib 폴더를 만들고 jar 파일을 복사해서 이클립스에 연결한다
	* JDBC 프로젝트 안에서 jar 파일을 참조 라이브러리로 쓰도록 등록한다
* 이를 통해 java에서 DB에 insert, select, update를 할 수 있다

#### 상세
##### Oracle 드라이버 로딩
```(java)
Class.forName("oracle.jdbc.driver.OracleDriver");
```
##### 필요한 객체
1. 연결 객체 Connection : DB랑 JAVA 연결
```
String url = "jdbc:oracle:thin:IP주소:PORT번호/DB이름"; //18C 버전
String uid = "DB접속ID";
String upw = "DB접속PW";
Connection conn = DriverManager.getConnection(url, uid, upw);
```
2. statement 객체 : SQL  전송/수신 객체
```
String sql = "실행할 sql문";
PreparedStatement pstmt = conn.prepareStatement(sql);
```
* sql문에 '?'를 사용해 입력받은 값으로 수행할 수도 있다.
	* 물음표 갯수에 따라 순서대로 1부터 인덱스가 부여된다
	* 아래와 같이 사용
```
pstmt.setInt(1, id)
```
* select일 때만 executeQuery를 사용하고
* 나머지에서는 executeUpdate를 사용한다 > 0,1 반환 > 성공 시 1
3. ResultSet 객체 : SQL문 조회 결과를 '전부' 받아옴
	* Select 문에서만 필요하다!
	* rs.next()를 통해 다음 행에 접근할 수 있다
```
ResultSet rs = pstmt.executeQuery();
```

#### 클래스로 빼는 방법
* java 파일로 하나씩 만들 수도 있지만 클래스에 메서드를 만들어 사용하면 더 간편하다
* 클래스에 (멤버) 정보를 저장하고 클래스 단위로 사용할 수 있다

#### 인터페이스로 사용하는 방법
* 추상메서드로 선언하고 DAO 클래스에서 오버로딩한다
